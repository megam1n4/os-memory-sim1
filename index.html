<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Memory Allocation Strategies Simulation</title>
    <link
      href="https://fonts.googleapis.com/css?family=Inter:400,600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", "Segoe UI", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #f8fafc;
        color: #222;
      }
      h1 {
        text-align: center;
        font-weight: 800;
        letter-spacing: 0.02em;
        margin: 4px 0 16px 0;
        font-size: 2.3rem;
        font-family: "Segoe UI", "Arial", sans-serif;
        color: #fff;
        background: #1877f2;
        border-radius: 14px;
        padding: 10px 0 12px 0;
        box-shadow: 0 2px 12px rgba(24, 119, 242, 0.1);
        text-shadow: 0 1px 2px #1453a3;
        -webkit-text-stroke: 0;
        text-stroke: 0;
        background-clip: border-box;
        -webkit-background-clip: border-box;
        -webkit-text-fill-color: #fff;
      }
      @keyframes neon-rgb {
        0% {
          background-position: 0% 50%;
        }
        100% {
          background-position: 200% 50%;
        }
      }
      /* Spin-in animation for main content */
      @keyframes spinIn {
        0% {
          opacity: 0;
          transform: scale(0.7) rotate(-540deg);
        }
        60% {
          opacity: 1;
          transform: scale(1.05) rotate(20deg);
        }
        80% {
          transform: scale(0.98) rotate(-5deg);
        }
        100% {
          opacity: 1;
          transform: scale(1) rotate(0deg);
        }
      }
      /* Slide-in animations for left and right panels */
      @keyframes slideInLeft {
        0% {
          opacity: 0;
          transform: translateX(-120vw) scale(0.96);
        }
        80% {
          opacity: 1;
          transform: translateX(2vw) scale(1.01);
        }
        100% {
          opacity: 1;
          transform: translateX(0) scale(1);
        }
      }
      @keyframes slideInRight {
        0% {
          opacity: 0;
          transform: translateX(120vw) scale(0.96);
        }
        80% {
          opacity: 1;
          transform: translateX(-2vw) scale(1.01);
        }
        100% {
          opacity: 1;
          transform: translateX(0) scale(1);
        }
      }
      #controls {
        padding: 20px 24px;
        background: #23272f;
        color: #fff;
        border-radius: 12px;
        margin: 0 auto 18px auto;
        max-width: 1200px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.07);
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 12px;
      }
      .param-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .param-group label {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .param-desc {
        font-size: 0.85rem;
        color: #a0aec0;
        margin-top: 2px;
      }
      #controls label {
        margin-right: 8px;
        font-size: 1rem;
        font-weight: 500;
      }
      #controls input {
        margin-right: 16px;
        border-radius: 6px;
        border: 1px solid #bbb;
        padding: 4px 8px;
        font-size: 1rem;
        font-family: inherit;
        outline: none;
        transition: border 0.2s;
      }
      #controls input:focus {
        border: 1.5px solid #4caf50;
      }
      #controls button {
        border: none;
        border-radius: 7px;
        padding: 7px 18px;
        font-size: 1rem;
        font-family: inherit;
        font-weight: 600;
        background: #4caf50;
        color: #fff;
        margin-right: 8px;
        cursor: pointer;
        box-shadow: 0 1px 4px rgba(44, 62, 80, 0.07);
        transition: background 0.18s, box-shadow 0.18s;
      }
      #controls button:hover:not(:disabled) {
        background: #388e3c;
        box-shadow: 0 2px 8px rgba(44, 62, 80, 0.12);
      }
      #controls button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .strategy-btn {
        background: #4caf50;
        color: #fff;
        font-weight: 500;
        margin-right: 8px;
        border-radius: 7px;
        border: none;
        padding: 7px 16px;
        transition: background 0.18s, color 0.18s, box-shadow 0.18s,
          transform 0.1s;
        box-shadow: none;
        position: relative;
      }
      .strategy-btn.selected {
        background: #145a1f !important; /* always dark green */
        color: #fff;
        font-weight: 700;
        box-shadow: 0 0 0 3px #000, 0 0 16px 4px #000a;
        z-index: 1;
        transform: scale(0.96) translateY(2px);
        border: 2.5px solid #145a1f;
        outline: none;
      }
      .strategy-btn.selected:active {
        filter: brightness(0.95);
        transform: scale(0.94) translateY(3px);
      }
      .strategy-btn:not(.selected):hover {
        background: #388e3c;
        color: #fff;
      }
      #main-content {
        display: flex;
        flex-direction: row;
        gap: 32px;
        justify-content: center;
        align-items: flex-start;
        margin: 0 auto;
        max-width: 1400px;
        opacity: 0;
        transform: scale(0.7) rotate(-540deg);
        transition: none;
      }
      #main-content.show-on-load {
        animation: spinIn 1.1s cubic-bezier(0.23, 1, 0.32, 1) 0.1s both;
      }
      #left-panel {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        gap: 24px;
        flex: 0 0 auto;
        opacity: 0;
        /* Will be animated in */
      }
      #left-panel.slide-in-left {
        animation: slideInLeft 2.2s cubic-bezier(0.23, 1, 0.32, 1) 0.1s both;
      }
      #results {
        font-size: 1.08rem;
        background: #f1f5f9;
        border-radius: 10px;
        padding: 18px 22px;
        min-width: 180px;
        max-width: 220px;
        box-shadow: 0 1px 6px rgba(44, 62, 80, 0.06);
        margin: 0;
        text-align: left;
        align-self: flex-start;
      }
      .results-section {
        margin-bottom: 16px;
      }
      .results-section h3 {
        color: #1a237e;
        margin: 0 0 12px 0;
        font-size: 1.2rem;
      }
      .results-section p {
        margin: 8px 0;
      }
      .results-section ul {
        margin: 8px 0;
        padding-left: 20px;
      }
      .results-section li {
        margin: 4px 0;
      }
      .warning {
        color: #e53935;
        font-weight: bold;
        margin-top: 12px;
        padding: 8px;
        background: #ffebee;
        border-radius: 4px;
      }
      #visualization {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
        flex: 1 1 120px;
        gap: 18px;
      }
      #memoryCanvas {
        background: #fff;
        border: 1.5px solid #cbd5e1;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(44, 62, 80, 0.07);
        display: block;
        max-height: 600px;
        width: 120px;
        height: 600px;
      }
      #plots {
        margin: 16px 0;
        display: flex;
        flex-direction: column;
        gap: 32px;
        align-items: flex-start;
        flex: 1 1 600px;
        opacity: 0;
        /* Will be animated in */
      }
      #plots.slide-in-right {
        animation: slideInRight 2.2s cubic-bezier(0.23, 1, 0.32, 1) 0.1s both;
      }
      #plots canvas {
        background: #fff;
        border: 1.5px solid #cbd5e1;
        border-radius: 10px;
        box-shadow: 0 2px 12px rgba(44, 62, 80, 0.07);
        margin-bottom: 0;
        width: 600px !important;
        height: 300px !important;
        max-width: 100%;
      }
      #errorMsg {
        color: #e53935;
        margin: 16px auto;
        font-weight: bold;
        text-align: center;
        font-size: 1.1rem;
        max-width: 900px;
      }
      #kernel-krew-credit {
        position: fixed;
        right: 18px;
        bottom: 12px;
        z-index: 1000;
        font-family: "Comic Sans MS", "Inter", Arial, sans-serif;
        font-size: 1.08rem;
        color: #fff;
        background: rgba(44, 62, 80, 0.82);
        border-radius: 8px 0 0 8px;
        padding: 7px 18px 7px 14px;
        box-shadow: 0 2px 12px #0004;
        letter-spacing: 0.04em;
        text-shadow: 0 0 8px #39ff14, 0 0 2px #000;
        user-select: none;
        pointer-events: none;
        line-height: 1.5;
      }
      #kernel-krew-credit .instructor {
        display: block;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 1rem;
        font-weight: 400;
        color: #ffe;
        letter-spacing: 0.01em;
        margin-top: 2px;
        text-shadow: none;
      }
      /* Error Modal Styles */
      #errorModal {
        display: none;
        position: fixed;
        z-index: 9999;
        left: 0;
        top: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.32);
        justify-content: center;
        align-items: center;
      }
      #errorModal[open],
      #errorModal.show {
        display: flex;
      }
      #errorModalContent {
        background: #fff;
        color: #e53935;
        border-radius: 12px;
        box-shadow: 0 4px 32px #0005;
        padding: 32px 36px 24px 36px;
        min-width: 320px;
        max-width: 90vw;
        text-align: center;
        font-size: 1.18rem;
        font-family: "Inter", Arial, sans-serif;
        font-weight: 600;
        border: 2.5px solid #e53935;
      }
      #errorModalOkBtn {
        background: #e53935;
        color: #fff;
        border: none;
        border-radius: 7px;
        padding: 8px 26px;
        font-size: 1.08rem;
        font-family: inherit;
        font-weight: 600;
        cursor: pointer;
        margin-top: 18px;
        box-shadow: 0 2px 8px #e5393530;
        transition: background 0.18s;
      }
      #errorModalOkBtn:hover {
        background: #b71c1c;
      }
    </style>
  </head>
  <body>
    <h1>Memory Allocation Strategies Simulation</h1>
    <div id="controls">
      <div class="param-group">
        <label
          >Mean request size (d):
          <input type="number" id="meanInput" min="1" value="20" />
          <span class="param-desc">Average size of memory requests (KB)</span>
        </label>
      </div>
      <div class="param-group">
        <label
          >Standard deviation (v):
          <input type="number" id="stddevInput" min="1" value="5" />
          <span class="param-desc">Variation in request sizes (KB)</span>
        </label>
      </div>
      <div class="param-group">
        <label
          >Memory size (n):
          <input type="number" id="memSizeInput" min="50" value="100" />
          <span class="param-desc">Total memory size (KB)</span>
        </label>
      </div>
      <button id="startBtn">Start Simulation</button>
      <span id="strategyBtns"></span>
      <button id="newParamsBtn" style="display: none">
        Try Different Parameters
      </button>
      <button id="resetBtn" style="display: inline-block">Reset All</button>
    </div>
    <div id="main-content">
      <div id="left-panel">
        <div id="results"></div>
        <div id="visualization">
          <canvas id="memoryCanvas" width="120" height="600"></canvas>
        </div>
      </div>
      <div id="plots" style="position: relative">
        <canvas id="utilPlot" width="600" height="300"></canvas>
        <canvas id="searchPlot" width="600" height="300"></canvas>
        <div
          id="plot-legend"
          style="
            position: absolute;
            left: 620px;
            top: 0;
            width: 140px;
            font-family: Inter, Arial, sans-serif;
            font-size: 15px;
            font-weight: 600;
          "
        >
          <div style="margin-bottom: 8px">&nbsp;</div>
          <div style="display: flex; align-items: center; margin-bottom: 8px">
            <span
              style="
                display: inline-block;
                width: 16px;
                height: 16px;
                background: #ffd600;
                border-radius: 50%;
                margin-right: 8px;
              "
            ></span>
            <span style="color: #ffd600">First Fit</span>
          </div>
          <div style="display: flex; align-items: center; margin-bottom: 8px">
            <span
              style="
                display: inline-block;
                width: 16px;
                height: 16px;
                background: #377eb8;
                border-radius: 50%;
                margin-right: 8px;
              "
            ></span>
            <span style="color: #377eb8">Next Fit</span>
          </div>
          <div style="display: flex; align-items: center; margin-bottom: 8px">
            <span
              style="
                display: inline-block;
                width: 16px;
                height: 16px;
                background: #43e97b;
                border-radius: 50%;
                margin-right: 8px;
              "
            ></span>
            <span style="color: #43e97b">Best Fit</span>
          </div>
          <div style="display: flex; align-items: center">
            <span
              style="
                display: inline-block;
                width: 16px;
                height: 16px;
                background: #e41a1c;
                border-radius: 50%;
                margin-right: 8px;
              "
            ></span>
            <span style="color: #e41a1c">Worst Fit</span>
          </div>
        </div>
      </div>
    </div>
    <div id="errorMsg"></div>
    <!-- Error Modal Popup -->
    <div id="errorModal" style="display: none">
      <div id="errorModalContent">
        <span id="errorModalMsg"></span>
        <button id="errorModalOkBtn" style="margin-top: 18px">OK</button>
      </div>
    </div>
    <!-- Credit message -->
    <div id="kernel-krew-credit">
      Credit: Kernel Krew!
      <span class="instructor">Instructor: Dr. Mary Kim</span>
    </div>
    <script>
      // Utility: Normal distribution using Box-Muller
      function randomNormal(mean, stddev) {
        let u = 0,
          v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return Math.round(num * stddev + mean);
      }

      // Memory simulation parameters
      let n = 100; // memory size
      let d = 20; // mean request size
      let v = 5; // stddev
      let memory = [];
      let allocatedBlocks = []; // [{start, size}]
      let strategy = "first-fit";
      let nextFitPos = 0;
      let searchTimes = [];
      let utilizations = [];
      let simulationRunning = false;
      let familyCurves = {}; // {strategy: {d: {util:[], search:[]}}}
      const strategies = ["first-fit", "next-fit", "best-fit", "worst-fit"];

      // Store simulation results per strategy and parameter set
      let simulationCache = {}; // {key: {memory, allocatedBlocks, results, utilizations, searchTimes}}

      function getSimKey(strat, d, v, n) {
        return `${strat}|${d}|${v}|${n}`;
      }

      // DOM elements
      const meanInput = document.getElementById("meanInput");
      const stddevInput = document.getElementById("stddevInput");
      const memSizeInput = document.getElementById("memSizeInput");
      const startBtn = document.getElementById("startBtn");
      const newParamsBtn = document.getElementById("newParamsBtn");
      const resetBtn = document.getElementById("resetBtn");
      const memoryCanvas = document.getElementById("memoryCanvas");
      const resultsDiv = document.getElementById("results");
      const strategyBtns = document.getElementById("strategyBtns");
      const utilPlot = document.getElementById("utilPlot");
      const searchPlot = document.getElementById("searchPlot");
      const errorMsg = document.getElementById("errorMsg");

      // Draw strategy buttons
      function drawStrategyButtons() {
        strategyBtns.innerHTML = "";
        strategies.forEach((strat) => {
          let btn = document.createElement("button");
          btn.textContent = strat
            .replace("-", " ")
            .replace(/\b\w/g, (l) => l.toUpperCase());
          btn.className = "strategy-btn";
          if (strat === strategy) btn.classList.add("selected");
          btn.onclick = () => {
            if (strategy === strat) return;
            strategy = strat;
            let key = getSimKey(strategy, d, v, n);
            if (simulationCache[key]) {
              restoreSimulation(simulationCache[key]);
            } else {
              runSimulation(true);
            }
            drawStrategyButtons(); // Always call to update pressed state
          };
          strategyBtns.appendChild(btn);
        });
      }
      drawStrategyButtons();

      // Restore simulation state from cache
      function restoreSimulation(cache) {
        memory = cache.memory.slice();
        allocatedBlocks = cache.allocatedBlocks.map((b) => ({ ...b }));
        searchTimes = cache.searchTimes.slice();
        utilizations = cache.utilizations.slice();
        resultsDiv.innerHTML = cache.resultsHTML;
        drawMemory();
      }

      // Initialize memory with random blocks and holes
      function initMemory() {
        memory = [];
        allocatedBlocks = [];
        let i = 0;
        // Generate initial memory state with normally distributed block sizes
        while (i < n) {
          // Generate block size from normal distribution
          let blockSize = Math.max(1, Math.min(n - i, randomNormal(d, v)));

          // Randomly decide whether to allocate or leave as hole
          if (Math.random() < 0.5 && i + blockSize < n) {
            // Allocate block
            memory[i] = blockSize;
            for (let j = 1; j < blockSize; j++) memory[i + j] = 0;
            allocatedBlocks.push({ start: i, size: blockSize });
          } else {
            // Create hole
            memory[i] = -blockSize;
            for (let j = 1; j < blockSize; j++) memory[i + j] = 0;
          }
          i += blockSize;
        }

        // Clean up any trailing zeros and ensure proper memory representation
        for (let i = 0; i < n; ) {
          if (memory[i] === 0) {
            memory[i] = -1; // Convert trailing zeros to 1-byte holes
            i++;
          } else {
            i += Math.abs(memory[i]);
          }
        }

        // Initial coalescing to ensure no adjacent holes
        coalesce();
      }

      // Visualization
      function drawMemory() {
        const ctx = memoryCanvas.getContext("2d");
        ctx.clearRect(0, 0, memoryCanvas.width, memoryCanvas.height);
        let y = 0,
          scale = memoryCanvas.height / n;
        ctx.font = "600 13px Inter, Segoe UI, Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < n; ) {
          let val = memory[i];
          let size = Math.abs(val);
          let height = size * scale;
          // Colors and style
          if (val > 0) {
            // Allocated block
            let grad = ctx.createLinearGradient(10, y, 110, y + height);
            grad.addColorStop(0, "#43e97b");
            grad.addColorStop(1, "#38f9d7");
            ctx.fillStyle = grad;
            ctx.strokeStyle = "#1de9b6";
          } else {
            // Hole
            let grad = ctx.createLinearGradient(10, y, 110, y + height);
            grad.addColorStop(0, "#e0e7ef");
            grad.addColorStop(1, "#b0bec5");
            ctx.fillStyle = grad;
            ctx.strokeStyle = "#90a4ae";
          }
          // Rounded rectangle
          drawRoundedRect(ctx, 10, y, 100, height, 10);
          ctx.stroke();
          ctx.fill();

          // Block size label
          ctx.save();
          ctx.beginPath();
          ctx.rect(10, y, 100, height);
          ctx.clip();
          ctx.fillStyle = val > 0 ? "#1b5e20" : "#607d8b";
          if (height > 18) {
            ctx.font = "600 13px Inter, Segoe UI, Arial, sans-serif";
            ctx.fillText(Math.abs(val) + " KB", 60, y + height / 2);
          }
          ctx.restore();

          y += height;
          i += size;
        }
      }

      // Helper: Draw rounded rectangle
      function drawRoundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      // Allocation strategies
      function findHole(size) {
        let holes = [];
        for (let i = 0; i < n; ) {
          let val = memory[i];
          if (val < 0 && -val >= size) holes.push({ start: i, size: -val });
          i += Math.abs(val);
        }
        if (strategy === "first-fit") return holes.length ? holes[0] : null;
        if (strategy === "next-fit") {
          let i = nextFitPos,
            count = 0;
          while (count < n) {
            let idx = (i + count) % n;
            let val = memory[idx];
            if (val < 0 && -val >= size) {
              nextFitPos = idx;
              return { start: idx, size: -val };
            }
            count += Math.abs(val || 1);
          }
          return null;
        }
        if (strategy === "best-fit") {
          let best = null;
          holes.forEach((h) => {
            if (!best || h.size < best.size) best = h;
          });
          return best;
        }
        if (strategy === "worst-fit") {
          let worst = null;
          holes.forEach((h) => {
            if (!worst || h.size > worst.size) worst = h;
          });
          return worst;
        }
        return null;
      }

      function allocate(size) {
        let searchCount = 0;
        let i = 0;
        let found = null;
        if (strategy === "first-fit") {
          for (; i < n; ) {
            let val = memory[i];
            searchCount++;
            if (val < 0 && -val >= size) {
              found = { start: i, size: -val };
              break;
            }
            i += Math.abs(val);
          }
        } else if (strategy === "next-fit") {
          let idx = nextFitPos,
            count = 0;
          while (count < n) {
            let val = memory[idx];
            searchCount++;
            if (val < 0 && -val >= size) {
              found = { start: idx, size: -val };
              nextFitPos = idx;
              break;
            }
            count += Math.abs(val || 1);
            idx = (idx + Math.abs(val || 1)) % n;
          }
        } else if (strategy === "best-fit" || strategy === "worst-fit") {
          let holes = [];
          for (let i = 0; i < n; ) {
            let val = memory[i];
            searchCount++;
            if (val < 0 && -val >= size) holes.push({ start: i, size: -val });
            i += Math.abs(val);
          }
          if (strategy === "best-fit") {
            holes.sort((a, b) => a.size - b.size);
          } else {
            holes.sort((a, b) => b.size - a.size);
          }
          found = holes.length ? holes[0] : null;
        }
        if (!found) return { success: false, searchCount };
        // Allocate
        let { start, size: holeSize } = found;
        memory[start] = size;
        for (let j = 1; j < size; j++) memory[start + j] = 0;
        if (holeSize > size) {
          memory[start + size] = -(holeSize - size);
          for (let j = 1; j < holeSize - size; j++)
            memory[start + size + j] = 0;
        }
        allocatedBlocks.push({ start, size });
        return { success: true, searchCount };
      }

      // Release a random block
      function releaseRandomBlock() {
        if (!allocatedBlocks.length) return false;
        let idx = Math.floor(Math.random() * allocatedBlocks.length);
        let { start, size } = allocatedBlocks[idx];
        memory[start] = -size;
        for (let j = 1; j < size; j++) memory[start + j] = 0;
        allocatedBlocks.splice(idx, 1);
        coalesce();
        return true;
      }

      // Coalesce adjacent holes
      function coalesce() {
        let i = 0;
        let safety = 0;
        while (i < n && safety < n * 2) {
          // safety limit
          let val = memory[i];
          if (val < 0) {
            let size = -val;
            let j = i + size;
            while (j < n && memory[j] < 0) {
              if (memory[j] === 0) break; // corrupted memory, stop
              size += -memory[j];
              memory[j] = 0;
              j += -memory[j];
            }
            memory[i] = -size;
            for (let k = i + 1; k < i + size; k++) memory[k] = 0;
          }
          i += Math.abs(val) || 1;
          safety++;
        }
        if (safety >= n * 2) {
          showError(
            "Coalesce safety limit reached. Possible memory corruption."
          );
          console.error("Coalesce safety limit reached", memory);
        }
      }

      // Memory utilization
      function memoryUtilization() {
        let used = 0;
        for (let i = 0; i < n; ) {
          let val = memory[i];
          if (val > 0) used += val;
          i += Math.abs(val);
        }
        return used / n;
      }

      // Error message display (popup modal)
      function showError(msg) {
        // Hide inline error
        errorMsg.textContent = "";
        // Show modal
        const modal = document.getElementById("errorModal");
        const modalMsg = document.getElementById("errorModalMsg");
        modalMsg.textContent = msg;
        modal.style.display = "flex";
        // Trap focus
        document.body.style.overflow = "hidden";
        document.getElementById("errorModalOkBtn").focus();
      }
      function clearError() {
        errorMsg.textContent = "";
        const modal = document.getElementById("errorModal");
        modal.style.display = "none";
        document.body.style.overflow = "";
      }
      // Modal OK button handler
      document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("errorModalOkBtn").onclick = clearError;
        // Optional: close modal on Enter key
        document
          .getElementById("errorModalOkBtn")
          .addEventListener("keyup", function (e) {
            if (e.key === "Enter" || e.key === " ") clearError();
          });
      });

      // --- Deterministic helpers (move these OUTSIDE runSimulation so they're always defined) ---
      function hashCode(str) {
        let hash = 0,
          i,
          chr;
        for (i = 0; i < str.length; i++) {
          chr = str.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        return hash;
      }
      function mulberry32(a) {
        return function () {
          var t = (a += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      // ------------------------------------------------------------

      // Plotting
      function plotCurves() {
        // Gather all unique d values across all strategies
        let allDsSet = new Set();
        strategies.forEach((strat) => {
          let data = familyCurves[strat];
          if (!data) return;
          Object.keys(data).forEach((dval) => allDsSet.add(Number(dval)));
        });
        let allDs = Array.from(allDsSet).sort((a, b) => a - b);

        // Utilization plot
        let ctx = utilPlot.getContext("2d");
        ctx.clearRect(0, 0, utilPlot.width, utilPlot.height);

        // Add more left margin for y-axis label and prevent cutoff
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, 60, utilPlot.height); // white margin for y-axis
        ctx.restore();

        ctx.font = "600 18px Inter, Arial";
        ctx.fillStyle = "#222";
        ctx.textAlign = "left";
        ctx.fillText("Avg Utilization vs d", 70, 32);

        // Draw grid lines and y-axis ticks/labels (percentages)
        ctx.strokeStyle = "#e0e7ef";
        ctx.font = "600 11px Inter, Arial"; // smaller y-axis tick font
        ctx.fillStyle = "#444";
        for (let y = 60, i = 0; y < utilPlot.height; y += 40, i++) {
          ctx.beginPath();
          ctx.moveTo(70, y);
          ctx.lineTo(utilPlot.width - 20, y);
          ctx.stroke();
          // y-axis labels (percentages)
          let percent = 100 - ((y - 60) / (utilPlot.height - 100)) * 100;
          let label = Math.round(percent / 10) * 10 + "%";
          ctx.textAlign = "right";
          ctx.fillText(label, 56, y + 2); // move left from 62 to 56
        }
        // Draw y-axis label with percentage
        ctx.save();
        ctx.translate(18, utilPlot.height / 2); // move further left from 32 to 18
        ctx.rotate(-Math.PI / 2);
        ctx.font = "600 12px Inter, Arial"; // smaller font for axis label
        ctx.fillStyle = "#222";
        ctx.textAlign = "center";
        ctx.fillText("Average Utilization (%)", 0, 0);
        ctx.restore();

        // Draw x-axis label
        ctx.font = "600 16px Inter, Arial";
        ctx.fillStyle = "#222";
        ctx.textAlign = "center";
        ctx.fillText(
          "Mean Request Size (d)",
          utilPlot.width / 2,
          utilPlot.height - 8
        );

        // Draw x-axis labels for all d values
        let xSpacing =
          allDs.length > 1 ? (utilPlot.width - 160) / (allDs.length - 1) : 0;
        allDs.forEach((dval, i) => {
          let x = 80 + i * xSpacing;
          ctx.fillStyle = "#222";
          ctx.font = "600 14px Inter, Arial";
          ctx.textAlign = "center";
          ctx.fillText(dval, x, utilPlot.height - 32);
        });
        // Colors: first-fit (yellow), next-fit (blue), best-fit (green), worst-fit (red)
        let colors = ["#ffd600", "#377eb8", "#43e97b", "#e41a1c"];
        // Draw data points and lines
        strategies.forEach((strat, idx) => {
          let data = familyCurves[strat];
          if (!data) return;
          ctx.strokeStyle = colors[idx];
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          let started = false;
          allDs.forEach((dval, i) => {
            let util = data[dval] ? data[dval].util[0] : null;
            if (util == null) return;
            let y = utilPlot.height - 60 - util * (utilPlot.height - 100);
            let x = 80 + i * xSpacing;
            if (!started) {
              ctx.moveTo(x, y);
              started = true;
            } else ctx.lineTo(x, y);
            ctx.fillStyle = colors[idx];
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2 * Math.PI);
            ctx.fill();
          });
          ctx.stroke();
        });

        // Search time plot
        ctx = searchPlot.getContext("2d");
        ctx.clearRect(0, 0, searchPlot.width, searchPlot.height);

        // Add more left margin for y-axis label and prevent cutoff
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, 60, searchPlot.height);
        ctx.restore();

        ctx.font = "600 18px Inter, Arial";
        ctx.fillStyle = "#222";
        ctx.textAlign = "left";
        ctx.fillText("Avg Search Time vs d", 70, 32);
        ctx.strokeStyle = "#e0e7ef";
        ctx.font = "600 13px Inter, Arial";
        ctx.fillStyle = "#444";
        // Draw grid lines and y-axis ticks/labels (holes)
        for (let y = 60, i = 0; y < searchPlot.height; y += 40, i++) {
          ctx.beginPath();
          ctx.moveTo(70, y);
          ctx.lineTo(searchPlot.width - 20, y);
          ctx.stroke();
          // y-axis labels (holes)
          let holes = Math.round((searchPlot.height - 60 - y) / 10);
          ctx.textAlign = "right";
          ctx.fillText(holes, 62, y + 2);
        }
        // Draw y-axis label with units
        ctx.save();
        ctx.translate(18, searchPlot.height / 2); // match left offset with utilization plot
        ctx.rotate(-Math.PI / 2);
        ctx.font = "600 12px Inter, Arial"; // match font size with utilization plot
        ctx.fillStyle = "#222";
        ctx.textAlign = "center";
        ctx.fillText("Average Search Time (holes)", 0, 0);
        ctx.restore();
        // Draw x-axis label
        ctx.font = "600 16px Inter, Arial";
        ctx.fillStyle = "#222";
        ctx.textAlign = "center";
        ctx.fillText(
          "Mean Request Size (d)",
          searchPlot.width / 2,
          searchPlot.height - 8
        );

        // Draw x-axis labels for all d values
        allDs.forEach((dval, i) => {
          let x = 80 + i * xSpacing;
          ctx.fillStyle = "#222";
          ctx.font = "600 14px Inter, Arial";
          ctx.textAlign = "center";
          ctx.fillText(dval, x, searchPlot.height - 32);
        });
        // Draw data points and lines
        strategies.forEach((strat, idx) => {
          let data = familyCurves[strat];
          if (!data) return;
          ctx.strokeStyle = colors[idx];
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          let started = false;
          allDs.forEach((dval, i) => {
            let search = data[dval] ? data[dval].search[0] : null;
            if (search == null) return;
            let y = searchPlot.height - 60 - search * 10;
            let x = 80 + i * xSpacing;
            if (!started) {
              ctx.moveTo(x, y);
              started = true;
            } else ctx.lineTo(x, y);
            ctx.fillStyle = colors[idx];
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2 * Math.PI);
            ctx.fill();
          });
          ctx.stroke();
        });
      }

      // Simulation loop
      function runSimulation(cacheThis = false) {
        try {
          clearError();
          simulationRunning = true;
          drawStrategyButtons(); // Ensure pressed state is always correct

          // Always use the same random seed for each (d, v, n) and strategy
          let seed = `${d},${v},${n},${strategy}`;
          let rand = mulberry32(hashCode(seed));
          // Patch randomNormal to use deterministic random
          function randomNormalDet(mean, stddev) {
            let u = 0,
              v = 0;
            while (u === 0) u = rand();
            while (v === 0) v = rand();
            let num =
              Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return Math.round(num * stddev + mean);
          }
          // Patch all simulation code to use randomNormalDet instead of randomNormal
          function initMemoryDet() {
            memory = [];
            allocatedBlocks = [];
            let i = 0;
            while (i < n) {
              let blockSize = Math.max(
                1,
                Math.min(n - i, randomNormalDet(d, v))
              );
              if (rand() < 0.5 && i + blockSize < n) {
                memory[i] = blockSize;
                for (let j = 1; j < blockSize; j++) memory[i + j] = 0;
                allocatedBlocks.push({ start: i, size: blockSize });
              } else {
                memory[i] = -blockSize;
                for (let j = 1; j < blockSize; j++) memory[i + j] = 0;
              }
              i += blockSize;
            }
            for (let i = 0; i < n; ) {
              if (memory[i] === 0) {
                memory[i] = -1;
                i++;
              } else {
                i += Math.abs(memory[i]);
              }
            }
            coalesce();
          }
          function releaseRandomBlockDet() {
            if (!allocatedBlocks.length) return false;
            let idx = Math.floor(rand() * allocatedBlocks.length);
            let { start, size } = allocatedBlocks[idx];
            memory[start] = -size;
            for (let j = 1; j < size; j++) memory[start + j] = 0;
            allocatedBlocks.splice(idx, 1);
            coalesce();
            return true;
          }
          // Use deterministic memory init
          initMemoryDet();
          nextFitPos = 0;
          searchTimes = [];
          utilizations = [];
          resultsDiv.innerHTML = "";

          const steps = 200;
          let allocAttempts = 0,
            allocSuccess = 0;
          let simSafety = 0;
          let hadAllocation = false;

          for (let step = 0; step < steps; step++) {
            if (simSafety++ > steps * 10) {
              showError("Simulation safety limit reached. Aborting.");
              break;
            }
            releaseRandomBlockDet();
            let tries = 0;
            while (tries < 5) {
              let reqSize = randomNormalDet(d, v);
              if (reqSize < 1 || reqSize > n - 1) {
                tries++;
                continue;
              }
              let { success, searchCount } = allocate(reqSize);
              allocAttempts++;
              if (!success) break;
              allocSuccess++;
              searchTimes.push(searchCount);
              tries++;
              hadAllocation = true;
            }
            utilizations.push(memoryUtilization());
          }

          drawMemory();

          let avgUtil =
            utilizations.length > 0
              ? utilizations.reduce((a, b) => a + b, 0) / utilizations.length
              : 0;
          let avgSearch =
            searchTimes.length > 0
              ? searchTimes.reduce((a, b) => a + b, 0) / searchTimes.length
              : 0;
          let allocRate =
            allocAttempts > 0
              ? ((allocSuccess / allocAttempts) * 100).toFixed(2)
              : "0.00";

          let resultsHTML = `
            <div class="results-section">
              <h3>Simulation Results</h3>
              <p><b>Strategy:</b> ${strategy
                .replace("-", " ")
                .replace(/\b\w/g, (l) => l.toUpperCase())}</p>
              <p><b>Parameters:</b></p>
              <ul>
                <li>Mean request size (d): ${d} KB</li>
                <li>Standard deviation (v): ${v} KB</li>
                <li>Memory size (n): ${n} KB</li>
              </ul>
              <p><b>Performance Metrics:</b></p>
              <ul>
                <li>Average Utilization: ${(avgUtil * 100).toFixed(2)}%</li>
                <li>Average Search Time: ${avgSearch.toFixed(
                  2
                )} holes examined</li>
                <li>Allocation Success Rate: ${allocRate}%</li>
              </ul>
            </div>`;

          if (!hadAllocation) {
            resultsHTML += `<p class="warning">No allocations succeeded. Try reducing d or increasing n.</p>`;
          }

          resultsDiv.innerHTML = resultsHTML;

          if (!familyCurves[strategy]) familyCurves[strategy] = {};
          if (!familyCurves[strategy][d])
            familyCurves[strategy][d] = { util: [], search: [] };
          if (familyCurves[strategy][d].util.length === 0) {
            familyCurves[strategy][d].util.push(avgUtil);
            familyCurves[strategy][d].search.push(avgSearch);
          }

          if (cacheThis) {
            let key = getSimKey(strategy, d, v, n);
            simulationCache[key] = {
              memory: memory.slice(),
              allocatedBlocks: allocatedBlocks.map((b) => ({ ...b })),
              resultsHTML,
              utilizations: utilizations.slice(),
              searchTimes: searchTimes.slice(),
            };
          }

          plotCurves();
          newParamsBtn.style.display = "inline-block";
        } catch (err) {
          showError("Simulation error: " + err.message);
          console.error(err);
        }
      }

      // Clear memory visualization
      function clearMemoryCanvas() {
        const ctx = memoryCanvas.getContext("2d");
        ctx.clearRect(0, 0, memoryCanvas.width, memoryCanvas.height);
      }

      // Reset all simulation state and UI
      function resetAll() {
        simulationRunning = false;
        familyCurves = {};
        memory = [];
        allocatedBlocks = [];
        searchTimes = [];
        utilizations = [];
        strategy = "first-fit";
        nextFitPos = 0;
        resultsDiv.innerHTML = "";
        clearError();
        clearMemoryCanvas();
        // Clear plots
        utilPlot
          .getContext("2d")
          .clearRect(0, 0, utilPlot.width, utilPlot.height);
        searchPlot
          .getContext("2d")
          .clearRect(0, 0, searchPlot.width, searchPlot.height);
        // Enable controls
        meanInput.disabled = false;
        stddevInput.disabled = false;
        memSizeInput.disabled = false;
        startBtn.disabled = false;
        newParamsBtn.style.display = "none";
        drawStrategyButtons();
      }

      // Popup for d, v
      function askParams() {
        meanInput.disabled = false;
        stddevInput.disabled = false;
        memSizeInput.disabled = false;
        startBtn.disabled = false;
        newParamsBtn.style.display = "none";
        resultsDiv.innerHTML = "";
        clearError();
        clearMemoryCanvas();
        // Clear simulation cache for new params
        simulationCache = {};
        // Always reset to first-fit when new params are requested
        strategy = "first-fit";
        drawStrategyButtons();
      }

      startBtn.onclick = () => {
        try {
          d = parseInt(meanInput.value);
          v = parseInt(stddevInput.value);
          n = parseInt(memSizeInput.value);
          // Validation: d must be less than n
          if (d >= n) {
            showError(
              "Error: Mean request size (d) must be less than memory size (n)."
            );
            return;
          }
          // Always start with first-fit
          strategy = "first-fit";
          meanInput.disabled = true;
          stddevInput.disabled = true;
          memSizeInput.disabled = true;
          startBtn.disabled = true;
          drawStrategyButtons();
          runSimulation();
        } catch (err) {
          showError("Startup error: " + err.message);
          console.error(err);
        }
      };

      newParamsBtn.onclick = () => {
        askParams();
      };

      resetBtn.onclick = () => {
        resetAll();
      };

      // Initial state
      askParams();
      clearMemoryCanvas();

      // Animation: Spin in main content on first load only
      window.addEventListener("DOMContentLoaded", function () {
        setTimeout(function () {
          document.getElementById("main-content").classList.add("show-on-load");
          document.getElementById("left-panel").classList.add("slide-in-left");
          document.getElementById("plots").classList.add("slide-in-right");
        }, 120);
      });
    </script>
  </body>
</html>
